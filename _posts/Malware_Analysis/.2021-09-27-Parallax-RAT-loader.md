---
layout: post
title: Parallax RAT Loader
category: Malware_Analysis
date: 2021/09/27
---


[TOC]



# summary :-

the SHA-256 of the loader sample is ```5DBC5B3553CDD5DF896629CD10A614CF1C384CFAFFFB0754898EE870589F5A10```

it said [that](https://malpedia.caad.fkie.fraunhofer.de/details/win.parallax) parallax RAT is one of infamous Malwares that spread during Covid-19 pandemic, as malpedia write about it 



![malpedia about parallax](../../assets/Images/Malware_Analysis/Parallax_RAT/malpedia.PNG)

in this blog Post we are not going to dive into the main RAT payload, instead we will focus in the loader phase and see how the loader preparing to launch the payload in low-detected and evasive way ... as it also [said](https://twitter.com/malwrhunterteam/status/1227196799997431809) that it detected by only one Engine in "Virus Total" when it submitted for the 1st time.

# Execution Flow :-

![main flow](../../assets/Images/Malware_Analysis/Parallax_RAT/flow.png)

the most special aspect about this loader is it very obfuscated an stealthy as we will dissect it now to see how it does this ...

the loader isn't embedded  the RAT payload  directly inside itself because it will be an easy hunt for any static-based detection to catch it, so it encode the payload inside a PNG image hosted at `Imgur{.}com` and  as part of it's execution it will download this PNG file and decode the payload from it.

__________________________________

### we can roughly divide execution flow as stages :-

- Preparation Phase => "launch, decryption and inject into Mstsc.exe-prepare downloader-" 
- Downloader Phase => download the PNG from `imgur` to `%TMP%`
- Parser Phase  =====> decode the PNG to produce the next 2 Phases code 
- Anti-Debugging  ===> which relay on `ZwQueryInformationProcess()` 
- Persistence   =====> establish Persistence and exclude the final Payloads from Defender detection 

### and to get a sense of the big picture of the execution flow, we need to know  pieces that build this full picture

1- `Decrypted PE file` => which is simply "xor decrypted"  data_blob to code contains

	a - PE File ->  prepare downloader and build `2nd_CFG_struct` -will be explained-
	b - shellcode -> responsible for image downloading stage 

2-  `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct` those are internal structures that every stage responsible to build and handover it to the next stage, and the whole point of this is obfuscation, this structs is containing 

- win API addresses 

-  Boolean values that control the flow 

- constant used during decompression or to access offsets

- Pointers and offsets inside the loader itself 

- executable names used as target for injection of the payload

and Definitions for those structures is showed in the following figures 

  

  

![1st_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct1.PNG)

![2nd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct2.PNG)

![3rd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct3.PNG)

**note** => the shellcode responsible of downloading PNG is the second member of ```_2nd_CFG_struct``` 

​         => the loader relay heavily to call ```ZwDelayExecution``` which is at offset ```0x24```here - so during analysis we ```*NOP slide*``` this API itself inside virtual memory of 				ntdll.dll itself 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay2.png)



and if we go for analysis without previous build of these structures `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct`  we will face something like this :- 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\no_cfg1.png)

before appling structres.

![if no CFG struct are defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\no_cfg.png)

but after those structure applied :-

![CFG defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\with_cfg.png)

------

so now we know the Phases of execution and the internal structures used by these phases, let's poke inside each phase of them 

~~~~
~~~~

## **A_) Preparation Phase :- "two part ( 1-preparation &  2-decrypted)"**

### Part1 => preparation

``` this part is contains how next stage code and url decrypted and moving execution with function pointer```

the first thing it does is to XOR decryption of code that prepare `2nd_CFG_struct` and also code responsible for Downloader part, this decryption is done with hardcoded Dword key 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec2.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec3.png)

the same thing is done for decryption of PNG URL, and also calling offset inside decrypted PE which is responsible for Building `2nd_CFG_struct` and calling the downloader passing to it the builded  struct ... **something worth mentioning here** the method of moving execution to shell code with function Pointer is less noisy than spawning another thread or injection because the shellcode here is doing a small job so this method is suitable for this situation

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url2.png)

after this we will move to 

### part2 => Decrypted

``` 
- how API procedures resolved in runtime by hashing.
- how malware map a second ntdll.dll from disk. 
- removing userland AV hooks.
- mixing 64-bit\32-bit code using heaven gates && how malware know the ssdt number without hardcode them "ssdt isn't fixed number across windows versions".
- how the malware inject into remote process using ( write - change entry - resume) style.
```

---

### ###   API resolving at runtime    ###

---

the malware resolve an API used in execution by these steps 

1. get the library base address by traversing PEB "Process environment Block" structure
2. pass CRC32 hash to resolving function that walk through all exports by dll and compare them against hash
3. after selecting the matching name of exported API, it will go through EOT "ordinals table" and EAT"addresses table" to get the address
4. storing the address of API in Stack Variable "local" {EBP-XXX} ... to obfuscate calls issued during execution
5. get SSDT number "system service descriptor table" "syscall table" for some of those APIs, to use them in "Heaven's gate" technique that will be explained later.

first thing the malware get PEB address of the current module, then it get the ```struct _PEB_LDR_DATA``` member inside PEB which hold this structure 

```c
 struct _PEB_LDR_DATA 
{ 
 ULONG Length; 
 BOOLEAN Initialized;  
 PVOID SsHandle; 
 LIST_ENTRY InLoadOrderModuleList; // +0x0c 
 LIST_ENTRY InMemoryOrderModuleList; // +0x14 
 LIST_ENTRY InInitializationOrderModuleList;// +0x1c 
} PEB_LDR_DATA; 
```



this structure where the malware can get the base address for example of Ntdll.dll, it will find this in any of the 3 "double linked list" => `InLoadOrderModuleList , InMemoryOrderModuleList and  InInitializationOrderModuleList` the only difference between them is the offset that the malware author choose to travel with :smile: and when he choose any of those 3 structures it will have a pointer `flink` which point to member on the "double linked list" of `_LDR_MODULE` structure  and from dereferencing this `flink` and access offsets inside  `_LDR_MODULE` 

```c++
struct _LDR_MODULE{ 
LIST_ENTRY          InLoadOrderModuleList;    
LIST_ENTRY          InMemoryOrderModuleList;   
LIST_ENTRY          InInitializationOrderModuleList; 
void*               BaseAddress; //0x18  
void*               EntryPoint;    
ULONG               SizeOfImage; 
UNICODE_STRING      FullDllName; 
UNICODE_STRING      BaseDllName; //0x2C
ULONG               Flags; 
SHORT               LoadCount; 
SHORT               TlsIndex; 
HANDLE              SectionHandle; 
ULONG               CheckSum; 
ULONG               TimeDateStamp; 
} LDR_MODULE;
```

so here the malware author choose to go with `InLoadOrderModuleList` . 

and the Pseudo-code to implement `get_base_of_dll( str dll_CRC32_hash )` is the following :-

- get PEB_address => `PEB = FS[30h]`  , `PEB = TIB[30h]`                  
-  go to `_PEB_LDR_DATA` => `LDR = PEB[0xC]` => author go for `LoadOrderModuleList`
-  go to Flink => `Flink = LDR[0xC]`                                    
-  loop through all linked list and get `BaseDllName`  => `Name = Flink[0x2C]`                                 
-  compare CRC32 hash of the current `BaseDllName`  with one supplied as argument =>  `if( CRC32hash(BaseDllName) == supplied_hash)`        
-  get the `BaseAddress` in `_LDR_MODULE` with matched  `matched_Flink[0x18]`                                  
-  otherwise - not matched - , continue loop linked list                                                                

and the C code implementation 

```c
int get_base_of_dll( int dll_CRC32_hash ){ 
    *PEB = NULL, 
    *Ldr_struct = NULL, 
    *Flink_ptr = NULL, 
    *p = NULL, 
    *BaseAddress = NULL, 
    *DllName = NULL; 
 
  __asm 
  { 
    mov eax,fs:[0x30] 
    mov PEB,eax 
  } 
  Ldr_struct = *( ( void ** )( ( unsigned char * )PEB+0x0c ) ); 
  Flink_ptr = *( ( void ** )( ( unsigned char * )Ldr_struct+ 0x0c ) ); 
  flink_iterator = Flink_ptr; 
  do
  { 
    
    DllName = *( ( void ** )( ( unsigned char * )flink_iterator+ 0x2C ) ); 
    if( CRC32Hasing(DllName) == dll_CRC32_hash ){
    		BaseAddress = *( ( void ** )( ( unsigned char * )flink_iterator+ 0x18 ) ); 
			};
    
    flink_iterator = *( ( void ** )flink_iterator); 
  } 
  while ( Flink_ptr != first_one ); 
  return BaseAddress; 
} 
```

and in the Hex-Ray's De-compiler  after adding required structures and fixing pointers, we could see the `get_base_of_dll()`  match what we explained so far :-

 ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\dll.png)

and it does this for getting the base address for `ntdll.dll , kernel32.dll` as the malware is only depend on low level APIs

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\dll1.png)

now with the two dll Base Address it will then move to resolving APIs, then store them in local Variables in the stack ... first let's talk about  how we identified the usage of CRC32 Hash algorithm before we use Scripting To comment out APIs used and facilitate the process of Static Analysis.

we know the function responsible of hash resolving by notice that there's function takes 2 argument 

​	1 - either ntdll_base or kernel32_base

​	2 - hardcoded hash

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func.png)

so going inside it we see that the result of `sub_1E2390()` compared against the supplied hash value 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func1.png)

and inside  `sub_1E2390()`  we found some sort of algorithm and inside it the "cryptographic constant" `0x4C11DB7` which is used in CRC32 hasing algorithm 

​                          ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\crc.png) 

so now it will be similar to how we get the base of dll by comparing the dll_name to hash ... now we calculate the hash for each exported name and compare it with the hash provided as argument, and if the compare done successfully, it will go through EAT "export address table" and EOT"export ordinal table" to get the address of procedure. 

the process of going from "Procedure name" to "Procedure address":-

```
1 = name_index = the index inside loop when Export Name matched with hash
2 = ordinal = ExportOrdinalTable [name_index ] 
3 = Procedure_address = ExportAddressTable [ordinal]  
```

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func2.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func3.png)

and this `API_Resolver()` is called many times to resolve many hashes, we need some sort of scripting to annotate each corresponding API name 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\api_resolving1.png)

and for annotating API names we will use a tool called [Uchihash](https://github.com/N1ght-W0lf/Uchihash) which is natively support CRC32 hashing algorithm and it also support producing IDA script that comment each hash with corresponding plaintext string.

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\abdl.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\crc32_script.png)

now we have seen how libraries and procedures are retrieved by only providing hash and relaying on process structures like `peb` , `_PEB_LDR_DATA` ,  `_LDR_MODULE` and PE `_IMAGE_EXPORT_DIRECTORY` ... next it will resolve many Procedure addresses and store them in stack variable to be used during execution.

​                                   ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\api_resolving.png)      

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\stack_api.png)



---

**how malware load a second ntdll.dll from disk.**

---

before the malware call any of resolved APIs and doing any malicious activity it try to load another ntdll.dll from disk to remove any userland AV hooks that set by Anti-Virus solutions.

most Anti-virus product set hooks on important Procedures exported by `ntdll.dll` , because it's the lowest layer in User space and all system calls are going through `ntdll.dll` so after hooking the AV engine can do it's role to monitor Procedures argument or watching any specific pattern of API calls then pass the execution back to the original called function, and the hook is done by changing the first assembly instruction in procedure address to `JMP AV_related_address `
and this hooking is done by AV_library injected in process address space upon creation of the process ... so let's see how this done inside the malware.



![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\ntdll.dll.png) 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\ntdll.png)   

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\map-ntdll-dbg.png)

**also  we can tell that this `ntdll.dll` isn't the one loaded by image loader, because the base address of this dll is low unlike the one loaded with windows image loader which is always have a [height base address](http://www.openrce.org/reference_library/files/reference/Windows%20Memory%20Layout,%20User-Kernel%20Address%20Spaces.pdf) inside the virtual address of the process **

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\manual_ntdll.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\ntdll-heigh-addr.png)



**note** most AV set hooks when they receive `PsSetCreateProcessNotifyRoutineEx()` callback , when process is created then it start setup inline hooks in important APIs, but when you map a dll in process memory like what malware author done here, it will be an aggressive way to scan all mapped file at run time in term of performance, so here if there's an hooks inside `ntdll.dll` loaded by windows loader, the other `ntdll.dll` mapped by the malware from disk will be clear from any hooks, so the next step malware will take is to scan all the exported procedures by `ntdll.dll` loaded by windows loader and clear inline hooks with the help of manually mapped `ntdll.dll` ... and the process is taking the following steps

* getting the address of exported function by `hooked_ntdll`

* getting the corresponding exported function address inside `mapped_ntdll`

* dereference the `hooked_ntdll`  exported function address, and compare the first byte with `E9` 'JMP opcode' 

* if the first byte match while comparing with `E9` == then ==> enter the unhooking loop 

  ```c#
   ----------------------------ZwProtectVirtualMemory--------------------------
     Address    ==> `hooked_ntdll`  exported function address
     Size       ==>  5 bytes ==> (JMP opcode'1 byte' + 32bit address'4bytes')
     NewProtect ==> PAGE_EXECUTE_READWRITE == 0x40
  ------------------------------------------------------------------------------
                                      ||
                                      ||
                                      ||
  ---------------------------ZwWriteVirtualMemory-------------------------------
       write 5 bytes from `mapped_ntdll` to  `hooked_ntdll` of current procedure 
  ------------------------------------------------------------------------------
                                      ||
                                      ||
                                      ||
   ----------------------------ZwProtectVirtualMemory--------------------------
     Address    ==> `hooked_ntdll`  exported function address
     Size       ==>  5 bytes ==> (JMP opcode'1 byte' + 32bit address'4bytes')
     NewProtect ==> PAGE_EXECUTE_READ == 0x20
  ------------------------------------------------------------------------------
  ```

  an in this next video explaining and showcase how the malware implement these steps :- 

{% include embed.html url="" %} -> unhooking



---
**mixing 64-bit\32-bit code using heaven gates && how malware know the SSDT number**

---

**not just trying to explain the technique which is explained already in many blog posts, but try to deliver the identification and discovering process from ''point of view'' of me ... as this is the first time to met usage of this technique **

in nutshell this technique is act as anti-analysis, and it take advantage of legitimate mechanism used by syswow64 subsystem, normally the mechanism intended for backward compatibility to let 32bit applications to work on 64bit operating system and this done by what's called `heaven's gate`, so the 32bit application work normally if it was on 32bit OS/machine by helping of syswow64 libraries which mapped into every 32bit application and this libraries provide the 32bit application the emulation of 32bit environment, **but the issue to address here** is that the kernel of  64bit system is purely run on 64bit code so when the 32bit emulated application need to issue syscall or any thing in kernel the `heaven's gate` act like dispatcher for those transitions ... and the malware implement this mechanism to execute 64bit code inside the 32bit application by abusing `heaven's gate` ... because in syswow64 situation the transition landed in address specified by the kernel ... but in the abusing situation the transition landed in 64bit code specified by the malware and crafted to execute malicious functionality behind the eyes of a 32bit debugger, because the debugging engine of 32bit debugger can't handle this execution and only catch the execution when it landed back in 32bit code ... unless you aware about the usage of this technique and use debugger  that can handle both architecture like `windbg` with `wow64exts` extension ... and we call it as anti-analysis because it hide some functionality from analyst, and isn't anti-debugging because in presence or absence of debugger it will do it's functionality and never change the execution flow based on debugger presence.

**technique identification** => so we identified the usage of this technique by noticing 3 things.

1. calls to `IsWow64Process()` function  and the Boolean  `IsWow_bool`   is act as decision maker to enter many code blocks or not  "heaven gates blocks"

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_bool.png)

so `IsWow_bool` is Boolean to  make decision about entering "heaven gates blocks" ... as shown here.

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\IsWow_bool.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_bool1.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_bool2.png)

2. after resolving some procedures the malware store `SSDT` number inside local vars ... those vars used by "heaven gates blocks"

   **two notes here**

   a. the malware get the SSDT number from the manually mapped `ntdll.dll` to evade that loaded dll may have hooks so the start of this hooked procedure address will have `JMP AV_related_address` instead of `MOV Eax, <SSDT number>` which is the normal case in not hooked ntdll.

   b. the malware get the SSDT number only for some functions "mostly the functions that at terminal position or last position in user mode", and not all functions starting with `MOV Eax, <SSDT number>` , because some function move the execution to another function or do some sort of checks on supplied parameters or something like converting string buffers from ASCII to Wide chars...

    

   ![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\ssdt1.png)

   

   so in the picture below we see the `dispatcher stub` which is the responsible of preparing the system call process, and it's start with instruction 
   `MOV Eax, <SSDT number>` so the malware dereference the Procedure address to get here and add 1 to this address to get the SSDT number, so adding 1 will skip MOV opcode `0xB8` and point to the next byte `0x3F` in this case.

   ![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\ssdt2.png)

3. there's function that take SSDT number as it's first argument and this function only called inside "heaven gates blocks" 

   and it referenced many times.

   ![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\ssdt3.png)

   ![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\ssdt4.png)

4. the wired delay and  jump to non-expected place that happen after execution of  "heaven gates blocks"

   {% include embed.html url="" %} -> wired jmp

after combining those 4  observations and trying to figure out ... the only thing matched with this behavior is come up when we saw the form of 
`JMP FAR` in `Wow64Transition()` ... and this explained next. 

 we will dissect important parts like:- `SSDT` , `segment selector` , `GDT `, `segment descriptor` , `JMP FAR` and windows segmentation.  

first, let's know what is SSDT number, 

**SSDT " System Service Dispatch Table"** :-  SSDT number is a index in array of pointers that indirectly call routines in kernel mode, this number used to specify kernel function to be executed by the kernel mode, and this number is used by assembly instructions like:-

* INT 0x2e ==> old mechanism to issue system call 
* SysEnter ==> x32 mechanism to issue system call
* SysCall   ==> x64 mechanism to issue system call

so the SSDT is the connection point between user-mode API calls and corresponding Kernel routines ... this connection is done through `dispatch stubs`.
the `dispatch stub` is  series of assembly instructions that prepare the transition to kernel mode 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\ssdt.png)

**note the "dispatch stubs" in the previous picture doesn't use `syscall` or `sysenter` ?** , 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\normal_syscall.png)

because in the context of this sample it's a x32bit inside x64 Operating  system, so the value `0x77894FC0`moved into `edx` then called must be something related to `WoW64` (**W**indows 32-bit **o**n **W**indows **64**-bit) which is a mechanism to preserve backward compatibility for 32bit applications to be able to run in 64bit architecture, and syswow64 is implemented by  `Wow64.dll`, `Wow64Win.dll`,  and `Wow64Cpu.dll` .

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_dll.png)

 and this address `0x77894FC0` is fixed between all transitions to kernel for API calls, 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_dispatcher.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\wow_dispatcher1.png)

for sake of simplicity,  let's think of `0x77894FC0`=>`Wow64Transition ` as general dispatcher that go from 32bit to 64bit as the name clarify that.
and inside it we see.

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\33_sgment.png)

"far pointer" explained from diagram in intel manual 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\33_sgment1.png)

so till now the address translation process according to intel manual is very normal and regular in case of the offset part ... the segment base address isn't affected according to current memory model the MS windows implement -- windows segmentation explained in the next photo -- but the only thing that changed than the normal flow in our assumption that there's some sort of bit flags related to  `segment descriptor`  pointed by `segment selector` `0x33`

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\segments.png)

and  to confirm that we go and see content of those segment registers while debugging both 32bit process and 64bit process.

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\32-cs.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\64-cs.png)

{% include embed.html url="" %} -> cs segment select

so before diving into segment descriptor structure and investigate bit flags responsible for this transition ... let's go to documentation and see the difference between `JMP => opcode E9`  and   `JMP FAR => opcode EA ` to conform our assumption.

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\33_sgment11.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\jmp-far_intel.png)

so that satisfy our assumption that `JMP FAR => opcode EA` change take segment into action not only the 32 bit address, but leave us with another non-related question ... how it change segments with the same privilege level, and we supposed to move to the kernel to execute out the syscall ??!!  but will leave this to be answered later 



so... in "Far pointer " the "segment selector" part of the address is pointing to "segment descriptor structure" inside the "GDT table", we will dissect that in case of `0x23` which is the values inside CS during execution of 32bit code and `0x33` which is the values inside CS during execution of 64bit code.

lets convert the two selector into binary then apply the segment selector structure to them according to intel manual 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\seg.selec.png)

firstly the segment selector of both `0x23` and `0x33` is still at user mode, so the flow of this must be like 

1. move SSDT in EAX    `&&`   jump to `Wow64Transition()` 

2. `Wow64Transition()` change the CS `code segment` to `0x33` that change execution mode to 64bit 

3. the 64bit code is now responsible to issue the `syscall` or not  then return back to `0x23`

   so there's no privilege level changing while entering the heaven gate ... we only change the execution mode, also what confirm that is the kernel is 64bit implemented and calling convention differ and registers set also differs ... so after moving to 64 bit code it can issue syscall but the heaven gate only responsible for change execution mode. 


let's now move now to index `4 => 0x23 => 32bit` and index `6 => 0x33 => 64bit`  in GDT and apply segment descriptor structure to it :- 

segment descriptor structure according to intel manual 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\descriptor_l_flag.png)

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\long.png)

let's verify the content of descriptors in index 4 and 6  by kernel debugging  with windbg. 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\seg.selec1.png)

the above output is from `dg` command which responsible for shows the segment descriptors, that

1.  descriptor at index `4 => 0x23 => 32bit` ====> descriptor[21] = long bit ==> NL "**N**ot **L**ong"
2.  descriptor at index `6 => 0x33 => 64bit` ====> descriptor[21] = long bit ==> LO " **LO**ng"

and both are code segments.

finally let's see the abuse technique is implemented inside parallax RAT:-

**Before going to analyze and disassemble the  64bit code inside 32bit  we need to make something clear here**

so during analysis process when we see any write of shellcode or PE file to process memory, the analyst go for extract or dump out this shellcode or PE file for getting notion of it's functionality or discard it if it was decoy to save time,  then the next step if we dealing with executable file format like PE file we do two things after dumping from memory :-

1. fix the sections offsets, and this done by see if the data inside sections is aligned according to file alignment `0x200`  in this case the PE is in raw mapping or according to page boundary alignment `0x000 = 1024`   in this case the PE is in virtual mapping.
2. changing some member of executable format structures like `optional_header.Entry Point` , `optional_header.ImageBase`, so when PE file loaded by windows loader or opened with disassembly tool, the parser or image activator are able to map the PE file into virtual form and traverse the import/export and rebase offsets in correct way.

but when we talk about decrypted PE file that was XOR Decrypted with hardcoded key in Preparation_Phase mentioned above, it have full format as PE file and all of it's headers but the execution flow is started and moved with building function pointers  

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\func_Ptr.png)

and it also replace hardcoded values with values and offsets generated at run-time

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\cbcb_1.png)

example of replacing 0xCBCBCBCB 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\cbcb_2.png)

other unique hardcoded values position calculation

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\cbcb_3.png)

 and also the PE file has no Imports in it's IAT and it's relying on hash resolved API and there's many moves of code to another locations or separated stage and it's very similar to PIC code `position independant` ... so in nutshell it decrypted in memory as PE file but in execution it's shellcode discarding any PE headers , and if you try to fix PE headers or section alignment as usual it will be waste of time and trying to disassemble it will result on missing some shellcode which will be discarded due to alignment and the header itself will be overwritten with shellcode 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\over_header.png)

 and it force you to create new segment structure to cover the whole code area ... so that's why we working with all stages in this sample as shellcode, and we will show case how to apply windows types and structures and propagate them in automated way to make the analysis easier 

**dealing with malformed PE file during execution stages**

to get around this problem we follow these steps **not in sequential order** :- 

1. dump Malformed PE file to disk.

2. remove the PE headers => by hex editor. 

3. we use IDA disassembler => manual load PE file.

4. add any windows  "MS SDK type library" to IDA from "Type libraries" subview.

5. produce C file => `file` tab => `produce file` => `create c file` 
   " if you use Ghidra  this step isn't required as Ghidra  enter each child in analysis Phase"

6. use `APIRetypeGUI.py`  which is available [here]([Miscellaneous/APIRetypeGUI.py at master · RolfRolles/Miscellaneous (github.com)](https://github.com/RolfRolles/Miscellaneous/blob/master/APIRetypeGUI.py)), => retrieve the proper type signature from IDA's type libraries

7. add  `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct`  structure definitions and apply them into code listing 
   " identified by the fact of **loading base address** then **dereference it** then **access many offsets within this base**  "

   ![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\struct00.PNG)

8. solve overlapped functions assemblies and define functions to match what we saw in debugging using these shortcuts

   ```
   - E --> extend function end 
   - alt+p --> edit function --> `local variables area`, `start address` and `end address`
   - delete function ---> in context menu "function names view"
   ```



**how parallax setup Heaven's gate prologue and epilogue** 



so now we will see **how to analyze 64bit code that will be executed in heaven gate**

------> binary ninja handle many architecture in the same analysis database

-----> in pe-bear 

{% include embed.html url="" %} -> be-bear heaven

{% include embed.html url="" %} -> why not resume

{% include embed.html url="" %} -> how continue

------



----

**how the malware inject into remote process using**

----



## B_) Downloader Phase :-

## C_) Parser Phase :-
## D_) Anti-Debugging:- 
## E_) Persistence :-

# Techniques :-
- obfuscate static analysis by building internal structure to each stage 
- resolving API by hashing "crc32" and traverse PEB 
- anti-analysis through mixing execution of 32-bit code and 64-bit code " using heaven gates "
- dynamic stack manipulation and referencing stack variables during execution
- decode payload from `PNG` photo 
- heavy usage of COM interfaces to do it's functionality 
- load `Ntdll.dll` from disk to evade userland AV Hooks and to confuse debugger symbolic Breakpoints
- anti-debugging through calling `ZwQueryInformationProcess()` either with `ProcessDebugPort => 0x07` or with `ProcessDebugObjectHandle => 0x1E`
- persistence through scheduled task using COM API masquerading `Iexplore.exe` which is just clean copy of main loader but with added cli parameters
- evade windows defender either with `powershell.exe Set-MpPreference -ExeclusionPath` or `reg.exe add <execltion dir from defernder>` accompanied with UAC bypass using `CMSTPLUA` COM interface