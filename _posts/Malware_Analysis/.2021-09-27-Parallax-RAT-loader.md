---
layout: post
title: Parallax RAT Loader
category: Malware_Analysis
date: 2021/09/27
---
# summary :-

the SHA-256 of the loader sample is ```5DBC5B3553CDD5DF896629CD10A614CF1C384CFAFFFB0754898EE870589F5A10```

it said [that](https://malpedia.caad.fkie.fraunhofer.de/details/win.parallax) parallax RAT is one of infamous Malwares that spread during Covid-19 pandemic, as malpedia write about it 



![malpedia about parallax](../../assets/Images/Malware_Analysis/Parallax_RAT/malpedia.PNG)

in this blog Post we are not going to dive into the main RAT payload, instead we will focus in the loader phase and see how the loader preparing to launch the payload in low-detected and evasive way ... as it also [said](https://twitter.com/malwrhunterteam/status/1227196799997431809) that it detected by only one Engine in "Virus Total" when it submitted for the 1st time.

# Execution Flow :-

![main flow](../../assets/Images/Malware_Analysis/Parallax_RAT/flow.png)

the most special aspect about this loader is it very obfuscated an stealthy as we will dissect it now to see how it does this ...

the loader isn't embedded  the RAT payload  directly inside itself because it will be an easy hunt for any static-based detection to catch it, so it encode the payload inside a PNG image hosted at `Imgur{.}com` and  as part of it's execution it will download this PNG file and decode the payload from it.

__________________________________

### we can roughly divide execution flow as stages :-

- Preparation Phase => "launch, decryption and inject into Mstsc.exe-prepare downloader-" 
- Downloader Phase => download the PNG from `imgur` to `%TMP%`
- Parser Phase  =====> decode the PNG to produce the next 2 Phases code 
- Anti-Debugging  ===> which relay on `ZwQueryInformationProcess()` 
- Persistence   =====> establish Persistence and exclude the final Payloads from Defender detection 

### and to get a sense of the big picture of the execution flow, we need to know 5 pieces that build this full picture

1- `Decrypted PE file` => which is simply "xor decrypted"  data_blob to code contains

	a - PE File ->  prepare downloader and build `2nd_CFG_struct` -will be explained-
	b - shellcode -> responsible for image downloading stage 

2-  `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct` those are internal structures that every stage responsible to build and handover it to the next stage, and the whole point of this is obfuscation, this structs is containing 

- win API addresses 

-  Boolean values that control the flow 

- constant used during decompression or to access offsets

- Pointers and offsets inside the loader itself 

- executable names used as target for injection of the payload

and Definitions for those structures is showed in the following figures 

  

  

![1st_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct1.PNG)

![2nd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct2.PNG)

![3rd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct3.PNG)

**note** => the shellcode responsible of downloading PNG is the second member of ```_2nd_CFG_struct``` 

​         => the loader relay heavily to call ```ZwDelayExecution``` which is at offset ```0x24```here - so during analysis we ```*NOP slide*``` this API itself inside virtual memory of 				ntdll.dll itself 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay2.png)



and if we go for analysis without previous build of these structures `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct`  we will face something like this :- 

![if no CFG struct are defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\no_cfg.png)

but after those structure defined :-

![CFG defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\with_cfg.png)

------

so now we know the Phases of execution and the internal structures used by these phases, let's poke inside each phase of them 

## A_) Preparation Phase :- "two part ( 1-preparation &  2-decrypted)"

### Part1 => preparation

``` this part is contains how next stage code and url decrypted and moving execution with function pointer```

the first thing it does is to XOR decryption of code that prepare `2nd_CFG_struct` and also code responsible for Downloader part, this decryption is done with hardcoded Dword key 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec2.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec3.png)

the same thing is done for decryption of PNG URL, and also calling offset inside decrypted PE which is responsible for Building `2nd_CFG_struct` and calling the downloader passing to it the builded  struct ... **something worth mentioning here** the method of moving execution to shell code with function Pointer is less noisy than spawning another thread or injection because the shellcode here is doing a small job so this method is suitable for this situation

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url2.png)

after this we will move to 

### part2 => Decrypted

``` 
- how api resolved in runtime by hashing.
- how malware load a second ntdll.dll from disk. 
- removing userland AV hooks.
- mixing 64-bit\32-bit code using heaven gates && how malware know the ssdt number without hardcode them "ssdt isn't fixed number".
- how the malware inject into remote process using ( write - change entry - resume) style.
```

### - API resolving at runtime 

the malware resolve an API used in execution by these steps 

1. get the library base address by traversing PEB "Process environment Block" structure
2. pass CRC32 hash to resolving function that walk through all exports by dll and compare them against hash
3. after selecting the matching name of exported API, it will go through EOT "ordinals table" and EAT"addresses table" to get the address
4. storing the address of API in Stack Variable "local" {EBP-XXX} ... to obfuscate calls issued during execution
5. get SSDT number "system service descriptor table" "syscall table" for some of those APIs, to use them in "Heaven's gate" technique that will be explained later.

first thing the malware get PEB address of the current module, then it get the ```struct _PEB_LDR_DATA``` member inside PEB which hold this structure 

```c
 struct _PEB_LDR_DATA 
{ 
 ULONG Length; 
 BOOLEAN Initialized;  
 PVOID SsHandle; 
 LIST_ENTRY InLoadOrderModuleList; // +0x0c 
 LIST_ENTRY InMemoryOrderModuleList; // +0x14 
 LIST_ENTRY InInitializationOrderModuleList;// +0x1c 
} PEB_LDR_DATA; 
```



this structure where the malware can get the base address for example of Ntdll.dll, it will find this in any of the 3 "double linked list" => `InLoadOrderModuleList , InMemoryOrderModuleList and  InInitializationOrderModuleList` the only difference between them is the offset that the malware author choose to travel with :smile: and when he choose any of those 3 structures it will have a pointer `flink` which point to member on the "double linked list" of `_LDR_MODULE` structure  and from dereferencing this `flink` and access offsets inside  `_LDR_MODULE` 

```c++
struct _LDR_MODULE{ 
LIST_ENTRY          InLoadOrderModuleList;    
LIST_ENTRY          InMemoryOrderModuleList;   
LIST_ENTRY          InInitializationOrderModuleList; 
void*               BaseAddress; //0x18  
void*               EntryPoint;    
ULONG               SizeOfImage; 
UNICODE_STRING      FullDllName; 
UNICODE_STRING      BaseDllName; //0x2C
ULONG               Flags; 
SHORT               LoadCount; 
SHORT               TlsIndex; 
HANDLE              SectionHandle; 
ULONG               CheckSum; 
ULONG               TimeDateStamp; 
} LDR_MODULE;
```

so here the malware author choose to go with `InLoadOrderModuleList` . 

and the Pseudo-code to implement `get_base_of_dll( str dll_CRC32_hash )` is the following :-

| get PEB_address                                              | `PEB = FS[30h]`    |  `PEB = TIB[30h]`                  |
| :----------------------------------------------------------- | ------------------------------------------------------- |
| go to `_PEB_LDR_DATA`                                        | `LDR = PEB[0xC]` => author go for `LoadOrderModuleList` |
| go to Flink                                                  | `Flink = LDR[0xC]`                                      |
| loop through all linked list and get `BaseDllName`           | `Name = Flink[0x2C]`                                    |
| compare CRC32 hash of the current `BaseDllName`  with one supplied as argument | `if( CRC32hash(BaseDllName) == supplied_hash)`          |
| get the `BaseAddress` in `_LDR_MODULE` with matched `Flink`  | `matched_Flink[0x18]`                                   |
| otherwise - not matched - , continue loop linked list        |                                                         |

and the C code implementation 

```c
int get_base_of_dll( int dll_CRC32_hash ){ 
    *PEB = NULL, 
    *Ldr_struct = NULL, 
    *Flink_ptr = NULL, 
    *p = NULL, 
    *BaseAddress = NULL, 
    *DllName = NULL; 
 
  __asm 
  { 
    mov eax,fs:[0x30] 
    mov PEB,eax 
  } 
  Ldr_struct = *( ( void ** )( ( unsigned char * )PEB+0x0c ) ); 
  Flink_ptr = *( ( void ** )( ( unsigned char * )Ldr_struct+ 0x0c ) ); 
  flink_iterator = Flink_ptr; 
  do
  { 
    
    DllName = *( ( void ** )( ( unsigned char * )flink_iterator+ 0x2C ) ); 
    if( CRC32Hasing(DllName) == dll_CRC32_hash ){
    		BaseAddress = *( ( void ** )( ( unsigned char * )flink_iterator+ 0x18 ) ); 
			};
    
    flink_iterator = *( ( void ** )flink_iterator); 
  } 
  while ( Flink_ptr != first_one ); 
  return BaseAddress; 
} 
```

and in the Hex-Ray's De-compiler  after adding required structures and fixing pointers, we could see the `get_base_of_dll()`  match what we explained so far :-

 ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\dll.png)

and it does this for getting the base address for `ntdll.dll , kernel32.dll` as the malware is only depend on low level APIs

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\dll1.png)

now with the two dll Base Address it will then move to resolving APIs, then store them in local Variables in the stack ... first let's talk about  how we identified the usage of CRC32 Hash algorithm before we use Scripting To comment out APIs used and facilitate the process of Static Analysis.

we know the function responsible of hash resolving by notice that there's function takes 2 argument 

​	1 - either ntdll_base or kernel32_base

​	2 - hardcoded hash

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func.png)

so going inside it we see that the result of `sub_1E2390()` compared against the supplied hash value 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func1.png)

and inside  `sub_1E2390()`  we found some sort of algorithm and inside it the "cryptographic constant" `0x4C11DB7` which is used in CRC32 hasing algorithm 

​                          ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\crc.png) 

so now it will be similar to how we get the base of dll by comparing the dll_name to hash ... now we calculate the hash for each exported name and compare it with the hash provided as argument, and if the compare done successfully, it will go through EAT "export address table" and EOT"export ordinal table" to get the address of procedure. 

the process of going from "Procedure name" to "Procedure address":-

```
1 = name_index = the index inside loop when Export Name matched with hash
2 = ordinal = ExportOrdinalTable [name_index ] 
3 = Procedure_address = ExportAddressTable [ordinal]  
```

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func2.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\hash_func3.png)

and this `API_Resolver()` is called many times to resolve many hashes, we need some sort of scripting to annotate each corresponding API name 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\api_resolving1.png)

and for annotating API names we will use a tool called [Uchihash](https://github.com/N1ght-W0lf/Uchihash) which is natively support CRC32 hashing algorithm and it also support producing IDA script that comment each hash with corresponding plaintext string.

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\crc32_script.png)

now we have seen how libraries and procedures are retrieved by only providing hash and relaying on process structures like `peb` , `_PEB_LDR_DATA` ,  `_LDR_MODULE` and PE `_IMAGE_EXPORT_DIRECTORY` ... next it will resolve many Procedure addresses and store them in stack variable to be used during execution.

​                                   ![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\api_resolving.png)      

**how malware load a second ntdll.dll from disk.** 

before the malware call any of resolved APIs and doing any malicious activity it try to load another ntdll.dll from disk to remove any userland AV hooks that set by Anti-Virus solutions.

most Anti-virus product set hooks on important Procedures exported by `ntdll.dll` , because it's the lowest layer in User space and all system calls are going through `ntdll.dll` so after hooking the AV engine can do it's role to monitor Procedures argument or watching any specific pattern of API calls then pass the execution back to the original called function, and the hook is done by changing the first assembly instruction in procedure address to `JMP AV_related_address `
and this hooking is done by AV_library injected in process address space upon creation of the process ... so let's see how this done inside the malware.



![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\ntdll.dll.png) 

![](C:\Users\csgaee\Desktop\github\csgaee.github.io\assets\Images\Malware_Analysis\Parallax_RAT\ntdll.png)   

**note** most AV set hooks when they receive `PsSetCreateProcessNotifyRoutineEx()` callback , when process is created then it start setup inline hooks in important APIs, but when you map a dll in process memory like what malware author done here, it will be an aggressive way to scan all mapped file at run time in term of performance, so here if there's an hooks inside `ntdll.dll` loaded by windows loader, the other `ntdll.dll` mapped by the malware from disk will be clear from any hooks, so the next step malware will take is to scan all the exported procedures by `ntdll.dll` loaded by windows loader and clear inline hooks with the help of manually mapped `ntdll.dll` 

B_) Downloader Phase :-

## C_) Parser Phase :-
## D_) Anti-Debugging:- 
## E_) Persistence :-

# Techniques :-
- obfuscate static analysis by building internal structure to each stage 
- resolving API by hashing "crc32" and traverse PEB 
- anti-analysis through mixing execution of 32-bit code and 64-bit code " using heaven gates "
- dynamic stack manipulation and referencing stack variables during execution
- decode payload from `PNG` photo 
- heavy usage of COM interfaces to do it's functionality 
- load `Ntdll.dll` from disk to evade userland AV Hooks and to confuse debugger symbolic Breakpoints
- anti-debugging through calling `ZwQueryInformationProcess()` either with `ProcessDebugPort => 0x07` or with `ProcessDebugObjectHandle => 0x1E`
- persistence through scheduled task using COM API masquerading `Iexplore.exe` which is just clean copy of main loader but with added cli parameters
- evade windows defender either with `powershell.exe Set-MpPreference -ExeclusionPath` or `reg.exe add <execltion dir from defernder>` accompanied with UAC bypass using `CMSTPLUA` COM interface