---
layout: post
title: Parallax RAT Loader
category: Malware_Analysis
date: 2021/09/27
---
# summary :-

the SHA-256 of the loader sample is ```5DBC5B3553CDD5DF896629CD10A614CF1C384CFAFFFB0754898EE870589F5A10```

it said [that](https://malpedia.caad.fkie.fraunhofer.de/details/win.parallax) parallax RAT is one of infamous Malwares that spread during Covid-19 pandemic, as malpedia write about it 



![malpedia about parallax](../../assets/Images/Malware_Analysis/Parallax_RAT/malpedia.PNG)

in this blog Post we are not going to dive into the main RAT payload, instead we will focus in the loader phase and see how the loader preparing to launch the payload in low-detected and evasive way ... as it also [said](https://twitter.com/malwrhunterteam/status/1227196799997431809) that it detected by only one Engine in "Virus Total" when it submitted for the 1st time.

# Execution Flow :-

![main flow](../../assets/Images/Malware_Analysis/Parallax_RAT/flow.png)

the most special aspect about this loader is it very obfuscated an stealthy as we will dissect it now to see how it does this ...

the loader isn't embedded  the RAT payload  directly inside itself because it will be an easy hunt for any static-based detection to catch it, so it encode the payload inside a PNG image hosted at `Imgur{.}com` and  as part of it's execution it will download this PNG file and decode the payload from it.

__________________________________

### we can roughly divide execution flow as stages :-

- Preparation Phase => "launch, decryption and inject into Mstsc.exe-prepare downloader-" 
- Downloader Phase => download the PNG from `imgur` to `%TMP%`
- Parser Phase  =====> decode the PNG to produce the next 2 Phases code 
- Anti-Debugging  ===> which relay on `ZwQueryInformationProcess()` 
- Persistence   =====> establish Persistence and exclude the final Payloads from Defender detection 

### and to get a sense of the big picture of the execution flow, we need to know 5 pieces that build this full picture

1- `Decrypted PE file` => which is simply "xor decrypted"  data_blob to code contains

	a - PE File ->  prepare downloader and build `2nd_CFG_struct` -will be explained-
	b - shellcode -> responsible for image downloading stage 

2-  `1st_CFG_struct` , `2nd_CFG_struct` and `3rd_CFG_struct` those are internal structures that every stage responsible to build and handover it to the next stage, and the whole point of this is obfuscation, this structs is containing 

- win API addresses 

-  Boolean values that control the flow 

- constant used during decompression or to access offsets

- Pointers and offsets inside the loader itself 

- executable names used as target for injection of the payload

and Definitions for those structures is showed in the following figures 

  

  

![1st_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct1.PNG)

![2nd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct2.PNG)

**note** => the shellcode responsible of downloading PNG is the second member of ```_2nd_CFG_struct``` 

â€‹         => the loader relay heavily to call ```ZwDelayExecution``` which is at offset ```0x24```here - so during analysis we ```*NOP slide*``` this API itself inside virtual memory of 				ntdll.dll itself 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\delay2.png)

![3rd_CFG_struct](..\..\assets\Images\Malware_Analysis\Parallax_RAT\struct3.PNG)

and if we go for analysis without previous build of these structures we will face something like this :- 

![if no CFG struct are defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\no_cfg.png)

but after those structure defined :-

![CFG defined](..\..\assets\Images\Malware_Analysis\Parallax_RAT\with_cfg.png)

------

so now we know the Phases of execution and the internal structures used by these phases, let's poke inside each phase of them 

## A_) Preparation Phase :- "two part ( 1-preparation &  2-decrypted)"

### Part1 => preparation

``` this part is contains how next stage code and url decrypted and moving execution with function pointer```

the first thing it does is to XOR decryption of code that prepare `2nd_CFG_struct` and also code responsible for Downloader part, this decryption is done with hardcoded Dword key 

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec2.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\xor_dec3.png)

the same thing is done for decryption of PNG URL, and also calling offset inside decrypted PE which is responsible for Building `2nd_CFG_struct` and calling the downloader passing to it the builded  struct ... **something worth mentioning here** the method of moving execution to shell code with function Pointer is less noisy than spawning another thread or injection because the shellcode here is doing a small job so this method is suitable for this situation

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url1.png)

![](..\..\assets\Images\Malware_Analysis\Parallax_RAT\url2.png)

after this we will move to 

### part2 => Decrypted

``` 
- how api resolved in runtime by hashing.
- how malware load a second ntdll.dll from disk. 
- removing userland AV hooks.
- mixing 64-bit\32-bit code using heaven gates && how malware know the ssdt number without hardcode them "ssdt isn't fixed number".
- how the malware inject into remote process using ( write - change entry - resume) style.
```



## B_) Downloader Phase :-

## C_) Parser Phase :-
## D_) Anti-Debugging:- 
## E_) Persistence :-

# Techniques :-
- obfuscate static analysis by building internal structure to each stage 
- resolving API by hashing "crc32" and traverse PEB 
- anti-analysis through mixing execution of 32-bit code and 64-bit code " using heaven gates "
- dynamic stack manipulation and referencing stack variables during execution
- decode payload from `PNG` photo 
- heavy usage of COM interfaces to do it's functionality 
- load `Ntdll.dll` from disk to evade userland AV Hooks and to confuse debugger symbolic Breakpoints
- remove hooks using Halo's Gate technique 
- anti-debugging through calling `ZwQueryInformationProcess()` either with `ProcessDebugPort => 0x07` or with `ProcessDebugObjectHandle => 0x1E`
- persistence through scheduled task using COM API masquerading `Iexplore.exe` which is just clean copy of main loader but with added cli parameters
- evade windows defender either with `powershell.exe Set-MpPreference -ExeclusionPath` or `reg.exe add <execltion dir from defernder>` accompanied with UAC bypass using `CMSTPLUA` COM interface